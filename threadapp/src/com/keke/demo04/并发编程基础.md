
### 什么是线程

现代操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，
这些线程都拥有各自的计数器、堆栈和局 部变量等属性，并且能够访问共享的内存变量。

### 为什么使用多线程

更多的处理器核心
更快的响应时间
更好的编程模型

### 线程的优先级

线程优先级不能作为程序正确性的依赖，
因为操作系统可以完全不用理会Java 线程对于优先级的设定。

### Daemon线程
Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。

当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。

可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。

###  起动与终止线程

构造线程对象 --> 启动线程

#### 中断

中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行

了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()

方法对其进行中断操作。

#### 过期的suspend()、resume()和stop()

大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作，那么对音乐播放 

做出的暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()

不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资
源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结 
一个线程时不会保证线程的资源正常释放，
通常是没有给予线程完成资源释放工作的机会， 因此会导致程序可能工作在不确定状态下。

意 正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建

议使用的过期方法，而暂停和恢复操作可以用后面提到的等待/通知机制来替代。

#### 安全地终止线程
过中断操作和cancel()方法均可使CountThread得以终止。
这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地
将线程停止，因此这种终止线程的做法显得更加安全和优雅。


### 线程间通讯
#### synchronized
**对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则
是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的**。无论采用哪种方式，其本质是对一
个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个
线程获取到由synchronized所保护对象的监视器。

**任意一个对象都拥有自己的监视器**，当这个对象由同步块或者这个对象的同步方法调用 

时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获

取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED 状态。

#### 等待/通知机制 wait 与 notify

一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个

过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模

式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良 好的伸缩性，

1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁
2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的 等待队列
3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或 notifAll()的线程释放锁之后，等待线程才有机会从wait()返回
4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED
5）从wait()方法返回的前提是获得了调用对象的锁


##### 等待/通知的经典范式 生产者和消费者模型

消费者：

1）获取对象的锁。 

2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 

3）条件满足则执行对应的逻辑。

```
synchronized(对象) { 
    while(条件不满足) { 
        对象.wait(); 
    }
    对应的处理逻辑 
}
```

生产者：

1）获得对象的锁。 

2）改变条件。 

3）通知所有等待在对象上的线程。

```
synchronized(对象) { 
    改变条件 
    对象.notifyAll(); 
}
```

#### Thread.join()的使用

#### ThreadLocal的使用