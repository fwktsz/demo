### 使用

### 实现

#### Lock接口
对于特殊场景，lock 比  synchronized方便

例如，针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得 

后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，

synchronized关键字就不那么容易实现了，而使用Lock却容易许多。

Lock接口提供的synchronized关键字不具备的主要特性如下：

### 队列同步器 AbstractQueuedSynchronizer AQS

AQS 是构建锁或者其他同步组件的基础框架
它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获 取线程的排队工作

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状 

态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3 

个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操 

作，因为它们能够保证状态的改变是安全的。

**锁是面向使用者的，它定义了使用者与锁交 互的接口**（比如可以允许两个线程并行访问），隐藏了实现细节；

**同步器面向的是锁的实现者， 它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作**。